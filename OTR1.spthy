theory OTR1
begin

builtins: diffie-hellman, revealing-signing

rule GenKey:
    [Fr(~sk)]
    -->
    [!Ltk($A, ~sk)]

rule Rev:
    [!Ltk(A, sk)]
    --[Reveal(A)]->
    [Out(sk)]

rule A_init:
    [Fr(~id), !Ltk($A, ~skA)]
    -->
    [St_I_1($A, $B, ~id, ~skA)]

rule B_init:
    [Fr(~id), !Ltk($B, ~skB)]
    -->
    [St_R_1($B, $A, ~id, ~skB)]

rule A_send1:
    [Fr(~x), St_I_1(A, B, id, skA)]
    -->
    [St_I_2(A, B, id, skA, ~x), Out(<revealSign('g'^~x, skA), pk(skA)>)]

rule B_recv1:
    let gy = getMessage(t) in 
    [In(<t, pkA>), St_R_1(B, A, id, skB)]
    --[Eq(revealVerify(t, gy, pkA), true)]->
    [St_R_2(B, A, id, skB, pkA, gy)]

rule B_send2:
    [Fr(~y), St_R_2(B, A, id, skB, pkA, gx)]
    -->
    [St_R_3(B, A, id, skB, pkA, gx, ~y), Out(<revealSign('g'^~y, skB), pk(skB)>)]

rule A_recv2:
    let gy = getMessage(t) in
    [In(<t, pkB>), St_I_2(A, B, id, skA, x)]
    --[Eq(revealVerify(t, gy, pkB), true), Finish()]->
    [St_I_3(A, B, id, skA, pkB, x, getMessage(t))]

restriction Equality:
    "All m1 m2 #i. Eq(m1, m2)@i ==> m1=m2" 

// Verified
lemma Executability:
    exists-trace "Ex #i. Finish() @i &  not (Ex A #j. Reveal(A)@j)"

end